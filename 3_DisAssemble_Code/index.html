<!DOCTYPE html>
<html lang="en">
<head>
<title>3 DisAssemble Code</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../tabs.css">
</head><body><h1>3 DisAssemble Code</h1><a href="../index.html">Back to index</a><br><br><div id="container"><input id="tab-1" type="radio" name="tab-group" checked="checked" />
<label for="tab-1">common</label><input id="tab-2" type="radio" name="tab-group" />
<label for="tab-2">ida</label><input id="tab-3" type="radio" name="tab-group" />
<label for="tab-3">radare2</label><div id="content"><div id="content-1"><body>
<h1 id="disassemble-code">(Dis)Assemble Code</h1>
<p>An integral part of a binary analyzation framework is to convert machine-code in a more human readable form. Normally, this is done on-the-fly when using the program. However, sometimes you may need to do this manually. It is also very useful to convert some assembly code fragments into machine code, for example when you want to write patches for binaries.</p>
<h2 id="exercise-1">Exercise 1</h2>
<p>Try to find out what platforms your framework supports for assemble and disassemble code</p>
<h2 id="exercise-2">Exercise 2</h2>
<p>Compile the following code-fragments into the machine-code (x86):</p>
<p><code>mov eax, 0xDEADBEEF</code></p>
<p>and</p>
<p><code>push eax</code><br />
<code>push ebx</code><br />
<code>pop eax</code><br />
<code>pop ebx</code></p>
<h2 id="exercise-3">Exercise 3</h2>
<p>Decompile the following machine-codes back into assembler-code:</p>
<p><code>B4 00 B0 13 CD 10</code> into x86 assembly code</p>
</div><div id="content-2"><body>
<h1 id="solutions-for-ida-pro">Solutions for IDA Pro</h1>
<p>Since we cannot assemble/disassemble code in IDA Pro itself, we have to use another tool. To make this easier, we just one an <a href="https://defuse.ca/online-x86-assembler.htm">online assembler/disassembler</a></p>
<h2 id="exercise-1">Exercise 1</h2>
<p>Since there is no way to view in IDA Pro what processors/architectures are supported directly, we have to look at the <a href="https://www.hex-rays.com/products/ida/processors.shtml">homepage</a>:</p>
<pre><code>IDA Starter Edition

IDA Starter Edition supports the following families (64-bit analysis is possible only with IDA Professional Edition)

AMD K6-2 3D-Now! extensions
32-bit ARM Architecture versions from v3 to v8 including Thumb, Thumb-2, DSP instructions and NEON Advanced SIMD instructions.
ARMv4/ARMv4T: ARM7 cores (ARM7TDMI/ARM710T/ARM720T/ARM740T), ARM9 cores (ARM9TDMI/ARM920T/ARM922T/ARM940T)
ARMv5/ARMv5TE/ARMv5TEJ: ARM9 cores (ARM946E-S/ARM966E-S/ARM968E-S/ARM926EJ-S/ARM996HS), ARM10E (ARM1020E/ARM1022E/ARM1026EJ-S)
ARMv6/ARMv6T2/ARMv6Z/ARMv6K: ARM11 cores (ARM1136J(F)-S/ARM1156T2(F)-S/ARM1176JZ(F)-S/ARM11 MPCore)
ARMv6-M: Cortex-M0/Cortex-M0+/Cortex-M1 (e.g. NXP LPC800/LPC1xxx, Freescale Kinetis L and M series, STM32 F0 series etc.)
ARMv7-M: Cortex-M3 (e.g. NXP LPC17xx/18xx/13xx, STM32 F1/F2/L1 series, TI Stellaris, Toshiba TX03/TMPM3xx etc.)
ARMv7E-M: Cortex-M4 (e.g. NXP LPC43xx, STM32 F3/F4 series, TI Stellaris LM4F, Freescale Kinetis K series and W series, Atmel AT91SAM4 etc.)
ARMv7-R: Cortex-R4(F)/Cortex-R5/Cortex-R7 (e.g. TI TMS570LS etc.)
ARMv7-A: Cortex-A5/Cortex-A7/Cortex-A8/Cortex-A9/Cortex-A12/Cortex-A15 (e.g. TI Sitara, TI OMAP series, Samsung S5PC100 and Exynos, Nvidia Tegra, Freescale i.MX, Allwinner A-Series and many others)
ARMv7 (custom): Apple A4/A5/A5X/A6/A6X (Swift microarchitecture, used in Apple&#39;s iPhone/iPod/iPad/AppleTV), Qualcomm Snapdragon
Note: this list is incomplete; code for any ARM-compliant core can be disassembled
ATMEL AVR (comes with source code)
DEC PDP-11(comes with source code)
Fujitsu FR (comes with source code)
GameBoy
Hitachi/Renesas H8/300, H8/300L, H8/300H, H8S/2000, H8S/2600, H8SX (comes with source code)
Hitachi H8/500(comes with source code)
Hitachi HD 6301, HD 6303, Hitachi HD 64180
INTEL 8080
INTEL 8085
INTEL 80196 (comes with source code)
INTEL 8051 (comes with source code)
INTEL 860XR (comes with source code)
INTEL 960 (comes with source code)
INTEL 80x86 and 80x87
INTEL Pentium family, including SSE, SSE2, SSE3, SSE4
Java Virtual Machine (comes with source code)
KR1878 (comes with source code)
Microsoft .NET (Common Language Infrastructure bytecode)
Mitsubishi MELPS740 or Renesas 740 (comes with source code)
Hitachi/Renesas M16C
MN102 (comes only with source code)
MOS Technologies 6502 (comes with source code)
Motorola/Freescale MC680xx, CPU32 (68330), MC6301, MC6303, MC6800, MC6801, MC6803, MC6805, MC6808, HCS08, MC6809, MC6811, M68H12C, ColdFire
Motorola MC6812/MC68HC12/CPU12
Freescale HCS12, HCS12X (including XGATE coprocessor)
NSC CR16 (comes only with source code)
NEC V850 and V850E1 (V850ES) (comes with source code)
EFI Byte Code (EBC) (comes with source code)
SPU (Synergistic Processing Unit of the Cell BE) (comes with source code)
MSP430, MSP430X (comes with source code)
PIC 12XX, PIC 14XX, PIC 18XX, PIC 16XXX (comes with source code)
Rockwell C39 (comes only with source code)
SAM8 (comes with source code)
SGS Thomson ST-7, and ST-20 (comes with source code)
TLCS900 (comes only with source code)
unSP from SunPlus
Philips XA series (51XA G3)(comes with source code)
Intel xScale
Z80, Zilog Z8, Zilog Z180, Zilog Z380 (comes with source code)
IDA Professional Edition

IDA Professional Edition supports all the Starter processors listed above plus the more complex ones listed below.

Analysis of 64 bit programs is possible with the IDA Professional.

x64 architecture (Intel x64 and AMD64)
ARM64 Architecture (aka AArch64)
ARMv8-A: Cortex-A50/Cortex-A53/Cortex-A57
ARMv8 (custom): Apple A7 (Cyclone microarchitecture, used in iPhone 5s)
Analog Devices AD218x series (ADSP-2181, ADSP-2183, ADSP-2184(L/N), ADSP-2185(L/M/N), ADSP-2186(L/M/N), ADSP-2187(L/N), ADSP-2188M/N, ADSP-2189M/N)
Dalvik (Android bytecode, DEX)
DEC Alpha
DSP563xx, DSP566xx, DSP561XX (comes with source code)
TI TMS320C2X, TMS320C5X, TMS320C6X, TMS320C64X, TMS 320C54xx, TMS320C55xx, TMS320C3 (comes with source code)
TI TMS320C27x/TMS320C28x
Hewlett-Packard HP-PA (comes with source code)
Hitachi/Renesas SuperH series: SH1, SH2, SH3, Hitachi SH4 (Dreamcast), SH-4A, SH-2A, SH2A-FPU
IBM/Motorola PowerPC/POWER architecture, including Power ISA extensions:
Book E (Embedded Controller Instructions)
Freescale ISA extentions (isel etc.)
SPE (Signal Processing Engine) instructions
AltiVec (SIMD) instructions
Hypervisor and virtualization instructions
All instructions from the Power ISA 2.06 specification (Vector, Decimal Floating Point, Integer Multiply-Accumulate, VSX etc.)
Cell BE (Broadband Engine) instructions (used in PlayStation 3)
VLE (Variable Length Encoding) compressed instruction set
Xenon (Xbox 360) instructions, including VMX128 extension
Paired Single SIMD instructions (PowerPC 750CL/Gekko/Broadway/Espresso, used in Nintendo Wii and WiiU)
Motorola/Freescale PowerPC-based cores and processors, including (but not limited to):
MPC5xx series: MPC533/MPC535/MPC555/MPC556/MPC561/MPC562/MPC563/MPC564/MPC566
Note: code compression features of MPC534/MPC564/MPC556/MPC566 (Burst Buffer Controller) are currently not supported
MPC8xx series (PowerQUICC): MPC821/MPC850/MPC860
MPC8xxx series (PowerQUICC II, PowerQUICC II Pro, PowerQUICC III): MPC82xx/MPC83xx/MPC85xx/MPC87xx
MPC5xxx series (Qorivva): MPC55xx, MPC56xx, MPC57xx
Power PC 4xx, 6xx, 74xx, e200 (including e200z0 with VLE), e500 (including e500v1, e500v2 and e500mc), e600, e700, e5500, e6500 cores
QorIQ series: P1, P2, P3, P4, P5 and T1, T2, T4 families
Infineon Tricore architecture (up to architecture v1.6)
Intel IA-64 Architecture - Itanium.
Motorola DSP 56K
Motorola MC6816
MIPS
MIPS Mark I (R2000)
MIPS Mark II (R3000)
MIPS Mark III: (R4000, R4200, R4300, R4400, and R4600)
MIPS Mark IV: R8000, R10000, R5900 (Playstation 2)
MIPS32, MIPS32r2, MIPS32r3 and MIPS64, MIPS64r2, MIPS64r3
Allegrex CPU (Playstation Portable), including VFPU instructions
Cavium Octeon ISA extensions
MIPS16 (MIPS16e) Application Specific Extension
MIPS-MT, MIPS-3D, smartMIPS Application Specific Extensions
Toshiba TX19/TX19A Family Application Specific Extension (MIPS16e+ aka MIPS16e-TX)
Mitsubishi M32R(comes with source code)
Mitsubishi M7700 (comes with source code)
Mitsubishi M7900 (comes with source code)
Nec 78K0 and Nec 78K0S (comes with source code)
STMicroelectronics ST9+, ST-10 (comes with source code)
SPARCII, ULTRASPARC
Siemens C166 (flow)
Fujitsu F2MC-16L, Fujitsu F2MC-LC (comes with source code)</code></pre>
<p>Please note that the free version and the demo version are only supporting some of them.</p>
<h2 id="exercise-2">Exercise 2</h2>
<p>This is a very simple task using the online tool, just input the code and select the wanted architecture, then press 'Assemble'.</p>
<pre><code>Raw Hex (zero bytes in bold): B8EFBEADDE   

0:  b8 ef be ad de          mov    eax,0xdeadbeef</code></pre>
<pre><code>Raw Hex (zero bytes in bold): 5053585B   

0:  50                      push   eax
1:  53                      push   ebx
2:  58                      pop    eax
3:  5b                      pop    ebx</code></pre>
<h2 id="exercise-3">Exercise 3</h2>
<p>Similar to exercise 2, just input the hex-values and then disassemble it:</p>
<pre><code>0:  b4 00                   mov    ah,0x0
2:  b0 13                   mov    al,0x13
4:  cd 10                   int    0x10</code></pre>
</div><div id="content-3"><body>
<h1 id="solutions-for-radare2">Solutions for Radare2</h1>
<p>To assemble / disassemble binaries, we can use the tool <code>rasm2</code> from the radare2 suite.</p>
<p>To get an overview of the capabilities of rasm2, we can look at the command line parameters using <code>rasm2 -h</code></p>
<pre><code>Usage: rasm2 [-CdDehLBvw] [-a arch] [-b bits] [-o addr] [-s syntax]
             [-f file] [-F fil:ter] [-i skip] [-l len] &#39;code&#39;|hex|-
 -a [arch]    Set architecture to assemble/disassemble (see -L)
 -b [bits]    Set cpu register size (8, 16, 32, 64) (RASM2_BITS)
 -c [cpu]     Select specific CPU (depends on arch)
 -C           Output in C format
 -d, -D       Disassemble from hexpair bytes (-D show hexpairs)
 -e           Use big endian instead of little endian
 -f [file]    Read data from file
 -F [in:out]  Specify input and/or output filters (att2intel, x86.pseudo, ...)
 -h           Show this help
 -i [len]     ignore/skip N bytes of the input buffer
 -k [kernel]  Select operating system (linux, windows, darwin, ..)
 -l [len]     Input/Output length
 -L           List supported asm plugins + features:
               a___ asm, _d__ disasm, __A_ analyzer, ___e ESIL
 -o [offset]  Set start address for code (default 0)
 -O [file]    Output file name (rasm2 -Bf a.asm -O a)
 -s [syntax]  Select syntax (intel, att)
 -B           Binary input/output (-l is mandatory for binary input)
 -v           Show version information
 -w           What&#39;s this instruction for? describe opcode
 If &#39;-l&#39; value is greater than output length, output is padded with nops
 If the last argument is &#39;-&#39; reads from stdin</code></pre>
<h2 id="exercise-1">Exercise 1</h2>
<p>The supported architectures can be listed using the command:</p>
<p><code>rasm2 -L</code></p>
<p>This gives us following list:</p>
<pre><code>_dA_  8          8051        PD      8051 Intel CPU
_dA_  16 32      arc         GPL3    Argonaut RISC Core
adAe  16 32 64   arm         BSD     Capstone ARM disassembler
_dA_  16 32 64   arm.gnu     GPL3    Acorn RISC Machine CPU
_d__  16 32      arm.winedbg LGPL2   WineDBG&#39;s ARM disassembler
_dA_  16 32      avr         GPL     AVR Atmel
adAe  16 32      bf          LGPL3   Brainfuck
_dA_  16         cr16        LGPL3   cr16 disassembly plugin
_dAe  32         cris        GPL3    Axis Communications 32-bit embedded processor
_dA_  16         csr         PD      Cambridge Silicon Radio (CSR)
adA_  32 64      dalvik      LGPL3   AndroidVM Dalvik
ad__  16         dcpu16      PD      Mojang&#39;s DCPU-16
_dA_  32 64      ebc         LGPL3   EFI Bytecode
_dAe  16         gb          LGPL3   GameBoy(TM) (z80-like)
_dA_  16         h8300       LGPL3   H8/300 disassembly plugin
_d__  32         hppa        GPL3    HP PA-RISC
_d__             i4004       LGPL3   Intel 4004 microprocessor
_dA_  8          i8080       BSD     Intel 8080 CPU
adA_  32         java        Apache  Java bytecode
_d__  8          lh5801      LGPL3   SHARP LH5801 disassembler
_dA_  16 32      m68k        BSD     Motorola 68000
_dA_  32         malbolge    LGPL3   Malbolge Ternary VM
adAe  16 32 64   mips        BSD     Capstone MIPS disassembler
adAe  32 64      mips.gnu    GPL3    MIPS CPU
_d__  16 32 64   msil        PD      .NET Microsoft Intermediate Language
_dA_  16         msp430      LGPL3   msp430 disassembly plugin
_dAe  32         nios2       GPL3    NIOS II Embedded Processor
_dA_  32 64      ppc         BSD     Capstone PowerPC disassembler
_dA_  32 64      ppc.gnu     GPL3    PowerPC
ad__             rar         LGPL3   RAR VM
_dA_  32         sh          GPL3    SuperH-4 CPU
_dAe  32 64      sparc       BSD     Capstone SPARC disassembler
_dA_  32 64      sparc.gnu   GPL3    Scalable Processor Architecture
_d__  16         spc700      LGPL3   spc700, snes&#39; sound-chip
_d__  32         sysz        BSD     SystemZ CPU disassembler
_dA_  32         tms320      LGPLv3  TMS320 DSP family
_dA_  32         v850        LGPL3   v850 disassembly plugin
_dA_  32         ws          LGPL3   Whitespace esotheric VM
_dAe  16 32 64   x86         BSD     Capstone X86 disassembler
a___  32 64      x86.nz      LGPL3   x86 handmade assembler
ad__  32         x86.olly    GPL2    OllyDBG X86 disassembler
a___  32         x86.tab     LGPL3   x86 table lookup assembler
_dAe  16 32 64   x86.udis    BSD     udis86 x86-16,32,64
_dAe  32         xcore       BSD     Capstone XCore disassembler
adA_  8          z80         NC-GPL2 Zilog Z80
_d__  8          z80.cr      LGPL    Zilog Z80</code></pre>
<p>The columns are:</p>
<ul>
<li>flags
<ul>
<li>a : assemble</li>
<li>d : disassemble</li>
<li>A : analyze</li>
<li>e : emulate</li>
</ul></li>
<li>bits</li>
<li>name</li>
<li>license</li>
<li>description</li>
</ul>
<h2 id="exercise-2">Exercise 2</h2>
<p>Using the output from exercise 1, we know that the name of the needed plugins for this example are</p>
<ul>
<li><code>x86</code></li>
<li><code>arm</code></li>
</ul>
<p>Translating a single instruction is pretty easy, we can just use the command<br />
<code>rasm2 'mov eax,0xdeadbeef'</code> to assemble into x86 code. However, sometimes it may be better to specify the architecture and bits explicitly (For example, when writing scripts for automatization):<br />
<code>rasm2 -a x86 -b 32 'mov eax,0xdeadbeef'</code></p>
<p>This gives us <code>b8efbeadde</code> as result.</p>
<p>To assemble more than 1 command, we can use a semicolon (<code>;</code>) to separate the commands:</p>
<p><code>rasm2 'push eax; push ebx; pop eax; pop ebx'</code></p>
<p>The assembly for this code-junk is now <code>5053585b</code></p>
<p>We can also specify to read from stdin using:</p>
<p><code>echo 'push eax; push ebx; pop eax; pop ebx' | rasm2 -f -</code></p>
<p>Which is very nice, because so we can also use for example a python script instead of the <code>echo</code> to write to stdin.</p>
<h2 id="exercise-3">Exercise 3</h2>
<p>Disassembling a binary is similar to exercise 2, but with the additional flag <code>-d</code>:</p>
<p><code>rasm2 -a x86 -d 'B4 00 B0 13 CD 10'</code></p>
<p>Gives us</p>
<pre><code>mov ah, 0
mov al, 0x13
int 0x10</code></pre>
</div></div></div></body>